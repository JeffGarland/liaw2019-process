#+Revision: 1
#+Audience: LEWGI
#+Status: 
#+Group: WG21
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [a4paper,10pt,titlepage,oneside,openany,final]
#+LATEX_HEADER:\setcounter{tocdepth}{2}
#+LATEX_HEADER:\usepackage[margin=0.8in]{geometry}
#+LATEX_HEADER:\usepackage{parskip}

#+Title: P1750R1 A Proposal to Add Process Management to the C++ Standard Library
#+Author: Klemens Morgenstern, Jeff Garland, Elias Kosunen, Fatih Bakir
#+Email: jeff@crystalclearsoftware.com

* Revision History
** R2

+   Removed pipes
+   Removed environment in ~this_process~
+   Removed environment stdio ~this_process~

** R1
+   Added a section of review questions and dicussion to record committee discussions - see Committee Questions and Discussions
+   LEWGI feedback: removed ~environment~ class
+   LEWGI feedback: can ~native_exit_code~ and ~exit_code~ be combined?
+   LEWGI feedback: removed ~process::operator~ bool
+   LEWGI feedback: removed ~process_group~ class
+   LEWGI feedback: removed ~native_handles~ from pipes
+   LEWGI feedback: are pids fundamental?
+   SG1 feedback: added a section on other c++ libraries with process management 
+   SG1 feedback: added section discussing the ~process~ destructor behavior
+   SG1 feedback: added section discussing issues around forward progress 
+   Make ~pipe~ a concrete, byte-based type, instead of a template over a character type. Removed ~basic_pipe~.
+   SG16 feedback: Remove ~char_traits~ and type aliases based on it from ~pipe~
+   Make ~pipe::read~ and ~pipe::write~ take a ~span~ instead of a pointer and a size
+   ~snake_case~ concepts, ~process_launcher~ -> ~default_process_launcher~ to avoid collisions
+   Add exposition-only ~process-argument-list~ concept
+   Fix Range-based templates, adding ~requires~-clauses
+   Fix ~tuple_element~ and ~get~ specializations for ~pipe~ and ~pstream~
+   Numerous editorial fixes

** R0
Initial release.

* Introduction

The creation and management of processes is a widely used and fundamental tool in computing systems.  Unfortunately, C++ does not have a portable way to create and manage processes. Most other language standard libraries support facilities to wrap the complexities in support of application programmers. The functionality has been on [[https://docs.google.com/document/d/1AC3vkOgFezPaeSZO-fvxgwzEIabw8I_seE7yFG_16Bk/preview][standard library wish lists]] going back to 2007. This proposal is based on [[https://www.boost.org/libs/process][boost.process]] which provides cross-platform implementation experience.

* Motivation and Scope

We propose a library to facilitate the following functionality:
+    create child processes on the current machine
+    setup streams for communication with child stdout and stderr
+    communicate with child processes through streams
+    wait for processes to exit 
+    terminate processes
+    capture the return result of a child process
+    optionally associate the child-process to the parent-child to children die with their parents, but not vice-versa.

The following illustrates an example usage of the proposed library. 

#+BEGIN_SRC c++

#include <process>

int main() {
  std::vector<std::string> args { "--version", "--std=c++2a" };

  try {
    auto tmp = std::filesystem::temp_directory_path() / "test-thingy";

    // Capture stdout, leave the others as the OS defaults
    std::process child("/usr/bin/g++", args, std::process_io({}, tmp, {})); 

    std::string line;
    std::ifstream fstr{tmp};
    while (fstr && std::getline(fstr, line) && !line.empty()) {
      std::cerr << line << std::endl;
    }
    child.wait();
  }
  catch (const std::process_error& e) {
    std::cerr << e.what();
  }
}
#+END_SRC

[[https://github.com/JeffGarland/liaw2019-process/tree/master/example][Additional user examples can be seen online]]. 

* Domain Terminology
** Processes
A process is an instance of a program in execution. A process has at least one thread. A process starts execution in the thread that invokes its main function. A child process is the result of another process creating or spawning the child. 

** Process Groups
Process groups allow for managing a set of processes at the operating system level. This allows behavior such as process termination to be automatically coordinated by the operating system. For example, child processes in a group can be set to terminate together.

** Pipes
A pipe is a unidirectional, serial communication line across processes. A pipe has two ends: a write end and a read end.

A pipe is buffered. The size of the buffer is implementation defined. When there's no data in the buffer, the pipe is called empty. When the buffer is full, the pipe is called full.

Reading from an empty pipe is a blocking operation. Writing to a pipe resumes any blocked threads that are waiting to read on that pipe.

Writing to a full pipe is a blocking operation. Reading from a pipe resumes any blocked threads that are writing to that pipe.

If there are multiple threads reading or writing from the same pipe at the same time the order in which they read the data is unspecified.

** Environment and Command Line Arguments

Creation of a child process sometimes involves modifying the environment for the child process. This proposal references a current proposal for [[http://wg21.link/p1725][P1275]] referencing a process environment. However, P1275 will need to be enhanced to support multiple instances of environments for access and modification of child process environment.

At this time the examples show in this proposal will require an enhanced P1275 to be functional.

* Survey of facilities in other standard libraries
** C/C++ system function

C and C++ currently provide a minimal process launching capability via the =system= function. The C++ function takes a =const char*= parameter that represents the command string to execute and an integer return code that signifies the execution return status. 

#+BEGIN_SRC c++

int result = system("echo \"foo\" > bar.txt");
if (result == 0) {
  // Success
}

#+END_SRC

This minimal facility lacks many aspects of process control needed for even basic applications, including access to the standard streams (stdin, stdout, stderr) of the child.

In addition it uses the system shell to interpret the command, which is a huge security hazard because of shell injection.

** Other C++ Libraries
*** ACE::Process
The Adaptive Communication Environment (ACE) library is an open source library that implements many wrappers around operating system primatives as part of concurrency and communications environment. The library has been ported to a myriad of platforms/operating systems.  It has been used in commercial applications since the late 1990's and is the core for TAO Common Object Request Broker (CORBA) implementation and the Data Distribution Service (DDS) openDDS implementation.

The primary type provided by the library for process management is [[http://www.dre.vanderbilt.edu/Doxygen/Stable/libace-doc/a06768.html][~ACE_Process~]].  This class provides the mechanisms to create and manage a child process. The [[http://www.dre.vanderbilt.edu/Doxygen/Stable/libace-doc/a06764.html][~ACE_Process_Options~]] class facilities the command line and environment setup.  In addition, the [[http://www.dre.vanderbilt.edu/Doxygen/Stable/libace-doc/a06776.html][~ACE_Process_Manager~]] for managing a group of processes.  

*** QT::Process
The QT libraries provide a widely used, widely ported, open source GUI framework for C++.

As part of the library, QT provides the core class [[https://doc.qt.io/qt-5/qprocess.html][QProcess]] with the facilities for process spawning and management. 

*** GNOME glib::spawn

The GNOME open source libraries (linux only) provide a [[https://developer.gnome.org/glibmm/stable/group__Spawn.html][set of functions to spawn]] and manage child processes in C++. Beyond basic functions, the functions provide both synchronous and asynchronous execution as well as pipe integration.

*** cpp-subprocess

The [[https://github.com/arun11299/cpp-subprocess][cpp-subprocess]] library uses C++-11 to provide a python-like interface to process management for a limited set of unix-like platforms.  The library supports pipe integration and environment setup.

*** Redirected Process (reproc)

The [[https://github.com/DaanDeMeyer/reproc][reproc]] library provides a cross-platform (windows and Posix) process management facility including stream integration.  The library supports stream and environment setup facilities.

** Java
Java provides a ProcessBuilder and stream piping facilities similar to what is proposed here. 

#+BEGIN_SRC java

// ProcessBuilder takes variadic string arguments
// or a List<String>
var builder = new ProcessBuilder("/bin/cat", "-");

// start()-method will spawn the process
// Standard streams are piped automatically
Process p = builder.start();

// Write into process stdin
new OutputStreamWriter(p.getOutputStream())
      .write("foo\n")
      .close(); // close() needed to flush the buffer

// Read from stdout
var reader = new BufferedReader(
                  new InputStreamReader(p.getInputStream()));
String output = reader.readLine();

assert output == "foo";

System.out.println("Exited with " + p.exitValue())

#+END_SRC

** Python

#+BEGIN_SRC python

from subprocess import run

# Command line arguments are all passed in a single list
# Standard streams aren't piped by default
result = run([ '/bin/cat', '-' ],
          input='foo\n', capture_output=True)
assert result.stdout == 'foo'
print("Exited with", result.returncode)

#+END_SRC

** Rust
As with other languages Rust provides the ability to pipe the results of the process into the parent.

#+BEGIN_SRC rust

use std::process::{Command, Stdio};

let mut child = Command("/bin/cat")
                .arg("-") // .args() also available, taking a range
                          // strings passed to .arg() are escaped
                .stdin(Stdio::piped())
                .stdout(Stdio::piped())
                .spawn()?; // ?-operator is for error handling
child.stdin.as_mut()?.write_all(b"foo\n")?;
// .wait_with_output() will, well, wait
// child.stdout/stderr exposes standard streams directly
let output = child.wait_with_output()?;
assert_eq!(b"foo", output.stdout.as_slice());
println!("Exited with {}", output.status.code.unwrap());

#+END_SRC

** Node.js

#+BEGIN_SRC js

const { spawn } = require('child_process');

// First argument is argv[0], rest of argv passed in a list
const p = spawn('/bin/cat', ['-']);
p.stdin.write('foo\n');
// Idiomatic node.js uses callbacks everywhere
p.stdout.on('data', (data) => {
  assert.StrictEqual(data, 'foo\n');
});
p.on('close', (code) => {
  console.log(`Exited with ${code}`);
});

#+END_SRC

* Committee Questions and Discussion
** Investigate combining ~exit_code~ and ~native_exit_code~

This question was raised in LEWGI in Cologne.
The two types are not obviously combinable and serve different purposes.
The reason for ~exit_code~ is so one can write portable cross-platform code.
The reason for ~native_exit_code~ is so one can write platform specific code.

** Are process ids (pids) fundamental for version 1?

The view of the authors is, that pids are fundamental in the same way that ~std::thread::id~ is fundamental.
Aside from being useful for applications in logging, they are also needed for interacting with the native APIs using the ~native_handle~.

** Investigate a non-exception api for error handling

This question was raised in LEWGI in Cologne.
It's clear, that the library can provide an API that uses error codes instead of exceptions.
This would look something like the following:

#+BEGIN_SRC c++

namspace std { 

struct process_make_ret {
  process    a_process;
  error_code error;
};

class process {
  friend make_process_ret make_process(...);
public:
  process(...);
};

process_make_ret make_process(...);
#+END_SRC

The unfortunate result is an API inconsistency with ~std::jthread~ and ~std::thread~, which are otherwise similar in usage to ~process~. 

Alternatively, users can write their own wrapper using the current proposal, since ~process~ has a default constructor and a ~valid~ member function. 

#+BEGIN_SRC c++

// User code

struct process_make_ret {
  std::process    process;
  std::error_code error;
};

process_make_ret make_process(...) {
  process_make_ret ret;
  try {
    ret.process = std::process(...);
  }
  catch (const std::system_error& err) {
    ret.error = err.code(); 
  }
}
#+END_SRC

** Splitting pipes out 
In Cologne both LEWGI and SG1 discussed if pipes should be part of a different stand alone proposal. This did not appear to be such an easy task from the authors view since IO with the process is quite fundamental to the proposal. 
However, since the Networking TS and related papers, are very active development, it seems counter-productive to add other IO objects before common conventions are established. By solving the issue through an extension point in ~process_io_traits~, we can provide a standard process library that can be used with pipes provided by a third library while at the same time propose a pipe library that fully fits in with future developments in IO libraries for C++.

** ~process~ destructor should not terminate

SG1 in Cologne discussed the behavior of the ~process~ destructor at length.
Originally, it was proposed, that the program would terminate if ~wait~ had not been called, like ~std::thread~ does.
The over arching backdrop of SG1 discussion was, that ~std::thread~ destructor calling terminate was a poor design choice, that was not to be repeated (see ~std::jthread~).

The authors would like committee guidance and discussion of some possible options, including:
- call ~process::terminate~ on child
- call ~wait~ by default in the destructor
- add some sort of ~request_stop~ interface to process to mirror ~std::jthread~ api
- a constructor option to pick from pre-defined behaviors like ~wait~ or ~detach~

Note that calling ~wait~ in the destructor can also cause poor behavior if the child process never exits.
This, however, is similar to the problem with ~jthread::join~, if the user fails to implement cooperative shutdown logic. 

The problem with a subprocess is however slightly different: the content of a subprocess is beyond the program's control, unlike the code a thread executes. Additionally, there is a way to terminate a child-process reliably on all operating systems, which is not true for threads. Hence this document proposes to terminate running & attached child processes in the destructor.

** Can ~std::process~ and ~std::thread~ interchangeably be used in generic code?

This was discussed in some length in SG1 in Cologne, with the general conclusion, that this proposal should not provide this feature.
While there was weak support for the idea, the domains are different enough, that it was deemed unnecessary.
Advice was to not pursue this issue further.

** Forward progress and core language impact

This was discussed at length by SG1 in Cologne. The question that started the discussion was:
- Can we piggyback on ~std::thread~'s forward progress stuff for ~process~ as well? 
- Can we assume all threads on the system behave like C++ threads?
- What can we say about the executing process?

Some key points included:
- It is impossible, in the scope of the standard, to describe the external process which is not necessarily C++
- We cannot assume forward progress, since it's not really possible for us to describe
- We should avoid trying to describe forward progress for ~process~

So, at this time, the proposal will say nothing.

* Design Discussion & Examples
** Naming conventions
All classes except for ~default_process_launcher~ in this paper carry the prefix ~process_~. This is because ~process~ was chosen as the adequate name for the class, which diverts from ~boost::process~, where ~process~ is the namespace and the class is ~process::child~. Do note however, that there is not technical reason that the prefixed classes couldn't be nested in ~process~, e.g. ~process::io~.

** Concept ~process_launcher~

A process launcher is a class that implements the actual launch of a process. In most cases there are different versions to do this. On Linux for example, ~vfork~ can be required as an alternative for fork on low-memory devices.
And while POSIX can change a user by utilizing setuid in a ~process_initializer~, Windows requires the invocation of a different function (~CreateProcessAsUserA~).

As an example for Linux:

#+BEGIN_SRC c++

#include <gnu_cxx_process>

__gnu_cxx::vfork_launcher launcher;
std::process my_proc("/bin/program", {}, launcher);

#+END_SRC

or for Windows:

#+BEGIN_SRC c++

__msvc::as_user_launcher{"1234-is-not-a-safe-user-token"};
std::process my_proc("C:\\program", {}, launcher);

#+END_SRC

In addition libraries may provide their launchers. The requirement is that there is an actual process with a pid as the result of launching the process.

Furthermore, the fact that the launcher has a well-specified ~launch~ function allows to launch a process like this:

#+BEGIN_SRC c++

std::default_process_launcher launcher;
auto proc = launcher.launch("/bin/foo", {});

#+END_SRC

Both versions make sense in their own way: on the one hand using the process constructor fits well in with the STL and it's RAII classes like thread. On the other hand it actually uses a factory-class, which can be used so explicitly.

** Concept ~process_initializer~

The process initializer is a class that modifies the behavior of a process. There is no guarantee that a custom initializer is portable, i.e. it will not only be dependent on the operating system but also on the process launcher. This is because an initializer might need to modify members of the launcher itself (common on Windows) and thus might break with another launcher.

Note that the concept might look different on other implementation, since additional event hooks might exist.

#+BEGIN_SRC c++

struct switch_user {
  ::uid_t uid;

  template<process_launcher Launcher>
  // Linux specific event, after the successful fork, called from the child process
  void on_exec_setup(Launcher&) {
    ::setuid(this->uid);
  }
};

std::process proc("/bin/spyware", {}, switch_user{42});

#+END_SRC

** Class ~process~
*** Constructor 

~process(const std::filesystem::path&, const process-argument-list&, Inits&&... init)~

This is the default launching function, and forwards to ~std::default_process_launcher~. Boost.process supports a cmd-style execution (similar to ~std::system~), which we opted to remove from this proposal.
This is because the syntax obscures what the library actually does, while introducing a security risk (shell injection).
Instead, we require the actually used (absolute) path of the executable. To simulate this behavior, an ~environment~ library, which is not part of this paper, would be required. 

#+BEGIN_SRC c++

std::system("git --version"); // Launches to cmd or /bin/sh

std::process("git", {"--version"}); // Throws process_error, exe not found
std::process("/usr/bin/git"), {"--version"}); // Works with an absolute path

// Or if we want to run it through the shell, note that /c is Windows specific
std::process("/bin/bash", {"-c", "git --version"});

#+END_SRC

The process-argument-list is a ~std::ranges::input_range~ of types that can be converted to ~basic_string_view~. In addition, there shall be overloads that accept a ~locale~ after the argument-list that is used for character conversions, similar to the constructor of ~std::filesystem::path~. Addtionally, there shall be explicit overloads using an ~initializer_list<basic_string_view>~ for all explicit aliases of ~basic_string_view~ defined in the standard.

*** Function ~wait~

The wait function waits for a process to exit. When replacing ~std::system~ it can be used like this:

#+BEGIN_SRC c++

const auto result_sys = std::system("gcc --version");

std::process proc("/usr/bin/gcc", {"--version"});
proc.wait();
const auto result_proc = proc.exit_code();

#+END_SRC

*** Function ~async_wait~

The ~wait_for~ and ~wait_until~ functions of ~boost::process~ have been difficult to implement, because there is no timed wait function in posix. 
While linux has an extension with ~sigtimedwait~ that can be used for a timed wait, others don't have such facilities. The two options there would be to either have a timer, that interrupts the waiting or to fork a process that waits and triggers the timeout through ~SIGCHLD~. Both of those options obscure the actual implementation. 

Thus it seems like better design, to utilize the upcoming executors for that. In the background they can install a single ~SIGCHLD~ handler to observe it for all processes as is currently done by ~asio::signal_set~. The user then can use a timer provided by the Networking TS to add a timeout.

#+BEGIN_SRC c++

std::process proc("/bin/python"), {"--version"});

std::io_context ioc;
std::steady_timer timer{ioc};
timer.expires_after(std::chrono::seconds(1));

int res = -1;

timer.async_wait([&](auto ec){ if (proc.running()) {proc.terminate();}})
proc.async_wait([&](auto ec, int exit_code){if (ec) res = exit_code;});

ioc.run();

#+END_SRC

Thus, this revision of the paper removes ~wait_for~ and ~wait_until~ functions in favor of ~async_wait~.

*** Function ~native_handle~

Since there is a lot functionality that is not portable, the ~native_handle~ is accessible. For example, there is no clear equivalent for ~SIGTERM~ on Windows. If a user still wants to use this, they could still do so:

#+BEGIN_SRC c++

std::process proc("/usr/bin/python", {});

::kill(proc.native_handle(), SIGTERM);
proc.wait();

#+END_SRC

*** Function ~native_exit_code~

The exit-code may contain more information on a specific system. Practically this is the case on POSIX. If a user wants to extract additional information they might need to use ~native_exit_code~.

#+BEGIN_SRC c++

std::process proc("/usr/bin/gcc", {});
proc.wait();
const auto exit_code = proc.exit_code(); // Equals to 1, since no input files

// Linux specific:
const bool exited_normally = WIFEXITED(proc.native_exit_code());

#+END_SRC

This is fundamentally different between posix & windows. While on posix, the exit-code has two components, windows uses a special value (259) to denote a process that is still active. 

** Class ~process_io~

~process_io~ takes three standard handles, because of requirements on most operating systems. With the second revision, pipes are removed from this paper, so that the io will rely on standardized types of the C++ standard.

The default, of course, is to forward it to ~std*~.

The ~process_io~ should be e template that allows designated initializers to work like this:

#+BEGIN_SRC c++

//Standard forwarding
std::process proc("foo", {}, std::process_io(stdin, stdout, stderr));

//Standard forwarding
std::process proc("foo", {}, std::process_io({.in = stdin,.out = stdout,.err = stderr});

#+END_SRC

/Note that ~process_io~ can be extended later, for example to support ~consteval~ IO, as proposed by P2237R0./

To keep this paper focussed, pipes has been removed from this paper. A pipe library can be seperate and more thoroughly based on the concepts of the networking TS and executors once they are finalized. 

Even if pipes were part of this paper, the ~process_io~ facilities should be extensible to user-code. This is a necessity, since the user might bring his own pipe or networking library, which he might want to assign to the standard I/O. E.g. a named pipe server on windows might be used to spawn a process on connect that handles the pipe I/O or an HTTP server might foward it's open TCP socket to a worker process. A popular example of using stdio for this kind of communication is sftp.

In theory, the user could also use the ~native_handle~ in order to use his own types. This is however very error-prone, since this type is commonly an ~int~ or a ~void*~.

In order to implement that, there shall be a template class ~process_io_traits~, that allows for a type to explicitly define how a given type passed to ~process_io~ can be assigned as a stream-handle.

#+BEGIN_SRC c++

template<typename T>
struct process_io_traits;

#+END_SRC

A type ~T~ will be considered a readable stream (i.e. a stream that can be used for ~stdin~) if ~process_io_traits~ has a static member function ~get_readable_handle(T)~ that returns a type convertible to ~process_io_traits<>::native_stream_handle~. A writeable stream (i.e. ~stdout~ and ~stderr~) shall have a ~process_io_traits<T>::get_writeable_handle~ function.


*** Using FILE*

The ~stdin~, ~stdout~ and ~stderr~ macros expand to an expression that yields a ~FILE*~. Since those are part of the standard already, they should be the supported way to assign ~stderr~ or ~stdout~.

The definition of ~process_io_traits<FILE*>~ might look as follows:

#+BEGIN_SRC c++

template<>
struct process_io_traits<FILE*> 
{
    static auto get_readable_handle(FILE* f) {return fileno(f);}
    static auto get_writeable_handle(FILE* f) {return fileno(f);}
};

#+END_SRC

*** Using files

Beyond ~FILE*~, the library shall support ~std::filesystem::path~, which will open a file for writing or reading. It is implementation defined when the file is exactly opened (e.g. after ~fork~ on posix is allowed).

#+BEGIN_SRC c++

std::filesystem::path log_path = "my_log_file";
std::system("foo > my_log_file");
// Equivalent:
std::process proc("foo", std::process_io{.out = std::filesystem::path(log_path)}));

#+END_SRC

*** Other objects 

Other objects, that use an underlying stream handle, could also be used. This is the case for tcp sockets (i.e. ~std::net::basic_stream_socket~).

#+BEGIN_SRC c++

std::net::tcp::socket sock(...) 
// Connect the socket

std::process proc("./server", std::process_io(socket, socket, "log-file"));

#+END_SRC

** Class ~process_env~

The big need of environment functions arises on the side of the child process, i.e. when a child queries it's own environment. For example, searching for an executable that emulates the shell behaviour would be quite common for starting processes, but is quite different between platforms:

On windows, a certain file name is search in the ~PATH~ (or ~Path~ sometimes) variable with the addition of the extensions available in ~PATHEXT~. On posix no such extensions exist, thus a function like  ~std::vector<std::filesystem::path> std::this_process::env::find_executable(std::string & name)~. 
Similarly, one might want to get the default shell of the OS, which on posix is stored in ~SHELL~ while it's deducable through ~windir~ on windows. This could be handled by a ~std::filesystem::path std::this_process::env::shell()~ function.

It is to note however, that this information is queried before process start and thus usually queried from the father environment. Thus adding those specialized functions to an environment that is used to initialize a child process, should be considered of little priority for this library. If another paper does provide such a class, we should support it. By generalizing it with concepts, we can plugin different ~environment~ libraries. By using views, this should be possible with little overhead.

If we discount specific values in an environment, the semantics are as follows:

1. It's a list of strings, in which every string contains at least one `=`
2. The part before the first `=` is a unique key
3. The part after the first `=` is the value, that is a `:` (posix) or `;` (windows) seperated list.

With these three characteristics we can define what types are acceptable as an environment to be set by the `process_env`:

1. `range<convertible_to<string_view>>`
2. `range<convertible_to<pair<string_view, string_view>>`
3. `range<convertible_to<pair<string_view, range<string_view>>>`

This will allow the environment to be used in all of the following ways:

#+BEGIN_SRC c++

std::vector<std::string> list_env;
std::process proc{"/bin/bash", {}, std::process_env{list_env}};

std::map<std::string, std::string> str_map_env;
std::process proc1{"/bin/bash", {}, std::process_env{str_map_env}};

std::map<std::string, std::vector<std::string>> lst_map_env;
std::process proc2{"/bin/bash", {}, std::process_env{lst_map_env}};

#+END_SRC

With an environment library like P1275R0 it could be use like this:

#+BEGIN_SRC
std::process proc{"/bin/bash", {}, std::process_env{std::environment}};
#+END_SRC

* Design Decisions
** Namespace std versus std::process

The classes and functions for this proposal could be put into namespace =std=, or a sub-namespace, such as =std::process=. Process is more similar to =std::thread= than =std::filesystem=. Since ~thread~ is in namespace =std= this proposal suggests the same for process.  The proposal also introduces namespace =std::this_process= for accessing attributes of the current process environment.

** Using a builder method to create

Have a =run()= method versus immediate launching in the constructor

This is solved through the extended launcher concept. 

#+BEGIN_SRC c++

// These are the same:
process(...) : process(default_process_launcher.launch(...)) {}
default_process_launcher().launch(...) -> process;

// These are the same:
process(..., custom_launcher& cl) : process(cl.launch) {}
cl.launch(...);

#+END_SRC

** ~wait~ or ~join~
The name of the method in ~class process~ was discussed at length.  The name ~join~ would be similar to ~std::thread~ while ~wait~ is more like various locking classes in the standard.  ~boost.process~ supports both.  The decision was to use ~wait~, but the name is open to bike shedding.

** Native Operating System Handle Support

The solution provides access to the operating system, like =std::thread=, for programmers who to go beyond the provided facilities.

** Security and User Management Implications

=std::system= is dangerous because of shell injection, which cannot happen with the uninterpreted version that is proposed here.

The standard process library does not touch on user management. As with file level visibility and user access the responsibility for user permissions lies outside the standard. For example, a process could fail to spawn as a result of the user lacking sufficient permissions to create a child process. This would be reflected as ~system_error~. 

** Extensibility

To be extensible this library uses two explicit concepts: =process_launcher= and =process_initializer=.

A =process_launcher= is the actual function creating the process. It can be used to provide platform dependent behavior such as launching a process a new user (Using =CreateProcessAsUser= on Windows) or to use =vfork= on Linux. The vendor can thus just provide a launcher, and the user can then just drop it into their code.

A =process_initializer= allows minor additions, that just manipulate the process. E.g. on Windows to set a =SHOW_WINDOW= flag, or on Linux to change the user with =setuid=.

Not having these customization points would greatly limit the applicability of this library.

The =process_launcher= has three methods that must be provided by a custom launcher.  These are:
+ ~on_setup~   - calls the initializer before attempting to launch
+ ~on_success~ - calls the initializer after successful process launch
+ ~on_error~ - On error passes an ~std::error_code~ to the initializer, so it can react, e.g. free up resources. The launcher must only throw after every initializer was notified.

** Error Handling

Uses exceptions by throwing a =std::process_error=. ~boost.process~ has an alternative error code based api similar to ~std::filesystem~. Field experience shows little actual usage of this api so it was not included in the proposal. 

** Synchronous Versus Asynchronous and Networking TS
Synchronous process management is prone to potential deadlocks. However used in conjunction with =std::thread= and other facilities synchronous management can be useful. Thus the proposal supports both styles.

~boost.process~ is currently integrated with ~boost.asio~ to support asynchronous behaviors. This proposal currently references the Networking TS for this behavior. However, this proposal can be updated to reflect changes to this aspect of the design since the committee is actively working on this design.

* Technical Specification

The following represents a first draft of an annotated technical specification without formal wording. For an initial proposal this is rather extensive, but hopefully clarifies the proposed library scope.

** Header ~<process>~ Synopsis

#+BEGIN_SRC c++

#include <chrono>
#include <filesystem>
#include <ranges>
#include <string>
#include <system_error>
#include <vector>
 
namespace std {
  // exposition-only, this concept shall be used as constraints inside the process constructor instead.
  // Command line argument list
  template<ranges::input_range R>
  concept process-argument-list =
    requires convertible_to<ranges::range_value_t<R>,    string_view> ||
    requires convertible_to<ranges::range_value_t<R>,   wstring_view> ||
    requires convertible_to<ranges::range_value_t<R>,  u8string_view> ||
    requires convertible_to<ranges::range_value_t<R>, u16string_view> ||
    requires convertible_to<ranges::range_value_t<R>, u32string_view>;

  // A launcher is an object that has a launch function that takes a path, 
  // arguments and a variadic list of process initializers and returns a process object. 
  template<class T, process-argument-list Args>
  concept process_launcher = requires(T launcher, const Args& a) {
    requires convertible_to<ranges::iter_value_t<ranges::iterator_t<Args>>, string>;
    // Takes an error_code, so initializers can report internal errors
    { launcher.set_error(error_code(), "message") } -> void;
    { launcher.launch(filesystem::path(), a) } -> process;
  };

  // The default process-launcher of the implementation
  class default_process_launcher;
  
  // An initializer is an object that changes the behavior of a process during launch 
  // and thus listens to at least one of the hooks of the launcher. 
  // Note that the following example only uses portable hooks, but non portables 
  // might suffice as well
  template<class Init, process_launcher Launcher = default_process_launcher>
  concept process_initializer =
       requires(Init initializer, Launcher launcher) 
       { {initializer.on_setup(launcher)}   -> void; }
    || requires(Init initializer, Launcher launcher) 
       { {initializer.on_success(launcher)} -> void; }
    || requires(Init initializer, Launcher launcher) 
       { {initializer.on_error(launcher, error_code())} -> void; };
  }

  // A pid_type is an identifier for a process, that satisfies StrictTotallyOrdered
  using pid_type = implementation-defined;

  // Provides a portable, unique handle to an operating system process
  // Satisfies Movable and Boolean, but not Copyable.
  class process;

  // Exception type thrown on error
  // Can have a filesystem::path attached to it (failing before launch), 
  // or pid_type (failing after)
  class process_error;

  // Concept of a readable stream, just for readability.
  concept process-readable-stream = requires(T a) {
    { process_io_traits<std::remove_reference_t<T>>{}.get_readable_handle(a) } -> std::convertible_to<typename process_io<>::native_stream_handle>;
  };

  // Concept of a writeable stream, just for readability.
  concept process-writeable-stream = requires(T a) {
    { process_io_traits<std::remove_reference_t<T>>{}.get_writeable_handle(a) } -> std::convertible_to<typename process_io<>::native_stream_handle>;
  };

  // Trait class to make IO extensible.
  template<process-readable-stream In, process-writeable-stream Out, process-writeable-stream Err>
  struct process_io;

  // Satisfies process_initializer
  class process_env;
  // Satisfies process_initializer
  class process_limit_handles;

  // Satisfies process_initializer
  class process_start_dir;
}

#+END_SRC

** Class ~process~

#+BEGIN_SRC c++

namespace std {
  class process {
  public:
    // Provides access to underlying operating system facilities
    using native_handle_type = implementation-defined; 
  
    // Construct a child from a property list and launch it.
    template<process-argument-list Args, process_initializer... Inits, process_launcher Launcher = default_process_launcher>
    explicit process(const filesystem::path& exe, const Args& args, Inits&&... inits, Launcher && ... launcher = {});

    // Construct a child from a property list and launch it with a custom locale for the character conversions of args.
    template<process-argument-list Args, process_initializer... Inits, process_launcher Launcher = default_process_launcher>
    explicit process(const filesystem::path& exe, const Args& args, const std::locale & loc, Inits&&... inits, Launcher && ... launcher = {});
  
    // Overload so we can use it like this: process("cmd", {"arg"});
    template<process_initializer... Inits, process_launcher Launcher = default_process_launcher>
    explicit process(const filesystem::path& exe, std::initializer_list<std::string_view> args, Inits&&... inits, Launcher && ... launcher = {});

    template<process_initializer... Inits, process_launcher Launcher = default_process_launcher>
    explicit process(const filesystem::path& exe, std::initializer_list<std::wstring_view> args, Inits&&... inits, Launcher && ... launcher = {});

    template<process_initializer... Inits, process_launcher Launcher = default_process_launcher>
    explicit process(const filesystem::path& exe, std::initializer_list<std::u8string_view> args, Inits&&... inits, Launcher && ... launcher = {});

    template<process_initializer... Inits, process_launcher Launcher = default_process_launcher>
    explicit process(const filesystem::path& exe, std::initializer_list<std::u16string_view> args, Inits&&... inits, Launcher && ... launcher = {});

    template<process_initializer... Inits, process_launcher Launcher = default_process_launcher>
    explicit process(const filesystem::path& exe, std::initializer_list<std::u16string_view> args, Inits&&... inits, Launcher && ... launcher = {});


    template<process_initializer... Inits, process_launcher Launcher = default_process_launcher>
    explicit process(const filesystem::path& exe, std::initializer_list<std::string_view> args, const std::locale & loc, Inits&&... inits, Launcher && ... launcher = {});

    template<process_initializer... Inits, process_launcher Launcher = default_process_launcher>
    explicit process(const filesystem::path& exe, std::initializer_list<std::wstring_view> args, const std::locale & loc, Inits&&... inits, Launcher && ... launcher = {});

    template<process_initializer... Inits, process_launcher Launcher = default_process_launcher>
    explicit process(const filesystem::path& exe, std::initializer_list<std::u8string_view> args, const std::locale & loc, Inits&&... inits, Launcher && ... launcher = {});

    template<process_initializer... Inits, process_launcher Launcher = default_process_launcher>
    explicit process(const filesystem::path& exe, std::initializer_list<std::u16string_view> args, const std::locale & loc, Inits&&... inits, Launcher && ... launcher = {});

    template<process_initializer... Inits, process_launcher Launcher = default_process_launcher>
    explicit process(const filesystem::path& exe, std::initializer_list<std::u16string_view> args, const std::locale & loc, Inits&&... inits, Launcher && ... launcher = {});

  
    // Attach to an existing process
    explicit process(const pid_type& pid);
  
    // An empty process is similar to a default constructed thread. It holds an empty 
    // handle and is a place holder for a process that is to be launched later.
    process() = default;

    process(process&&) = default;
    process& operator=(process&&) = default;
    
    // tbd behavior
    ~process();
  
    // Accessors 
  
    pid_type id() const;
  
    native_handle_type native_handle() const;
  
    // Return code of the process, only valid if !running()
    int exit_code() const;

    // Return the system native exit code. That is on Linux it contains the 
    // reason of the exit, such as can be detected by WIFSIGNALED 
    int native_exit_code() const;

    // Check if the process is running. If the process has exited already, it might store 
    // the exit_code internally.
    bool running() const;
  
    // Check if this handle holds a child process.
    // NOTE: That does not mean, that the process is still running. It only means, that 
    // the handle does or did exist.
    bool valid() const;
  
    // Process management functions
  
    // Detach a spawned process -- let it run after this handle destructs
    void detach();
  
    // Terminate the child process (child process will unconditionally and immediately exit)
    // Implemented with SIGKILL on POSIX and TerminateProcess on Windows
    void terminate();
  
    // Block until the process to exits 
    void wait();
     
    // The following is dependent on the networking TS. CompletionToken has the signature 
    // (int, error_code), i.e. wait for the process to exit and get the exit_code if exited. 
    template<class Executor, class CompletionToken>
    auto async_wait(Executor& ctx, CompletionToken&& token);
  };
}

#+END_SRC

** Class ~process_error~

#+BEGIN_SRC c++

class process_error : public system_error {
public:
  // filesystem_error can take up to two paths in case of an error
  // In the same vein, process_error can take a path or a pid
  process_error(const string& what_arg, error_code ec);
  process_error(const string& what_arg, 
                const filesystem::path& path,
                std::error_code ec);
  process_error(const string& what_arg, 
                pid_type pid_arg,
                std::error_code ec);

  const filesystem::path& path() const noexcept;
  pid_type pid() const noexcept;

  const char* what() const noexcept override;
};

#+END_SRC

** Class ~process_io~

#+BEGIN_SRC c++

namespace std {
  // This class describes I/O redirection for the standard streams (stdin, stdout, stderr).
  // They all are to be set, because Windows either inherits all or all need to be set. 
  // Satisfies process_initializer
  template<process-readable-stream In = implementation-defined, process-writeable-stream Out = implementation-defined, process-writeable-stream Err = implementation-defined>
  struct process_io {
    // OS dependent handle type
    using native_stream_handle = implementation-defined;

    In  in  = implementation-defined;
    Out out = implementation-defined;
    Err err = implementation-defined;    
    
    // The rest is implementation-defined
  };
}

#+END_SRC


** Class ~process_env~

#+BEGIN_SRC c++
namespace std {

  // This class sets the environment for the child environment.
  // 
  class process_env {
    public:
    //string range
    template<ranges::range R>
        requires (
            requires(ranges::range_value_t<R> r) {{r} -> convertible_to<   string_view>;} ||
            requires(ranges::range_value_t<R> r) {{r} -> convertible_to<  wstring_view>;} ||
            requires(ranges::range_value_t<R> r) {{r} -> convertible_to< u8string_view>;} ||
            requires(ranges::range_value_t<R> r) {{r} -> convertible_to<u16string_view>;} ||
            requires(ranges::range_value_t<R> r) {{r} -> convertible_to<u32string_view>;}
            )
    process_env(R && r);

    //string range to be converted with the given locale.
    template<ranges::range R>
        requires (
            requires(ranges::range_value_t<R> r) {{r} -> convertible_to<   string_view>;} ||
            requires(ranges::range_value_t<R> r) {{r} -> convertible_to<  wstring_view>;} ||
            requires(ranges::range_value_t<R> r) {{r} -> convertible_to< u8string_view>;} ||
            requires(ranges::range_value_t<R> r) {{r} -> convertible_to<u16string_view>;} ||
            requires(ranges::range_value_t<R> r) {{r} -> convertible_to<u32string_view>;}
            )
    process_env(R && r, const std::locale & loc);


    //string pair range
    template<ranges::range T>
        requires (
        requires(ranges::range_value_t<T> r) 
        {
        {tuple_size<ranges::range_value_t<T>>{}} -> convertible_to<integral_constant<std::size_t,2u>>;
        }          
        &&
         (
             requires(ranges::range_value_t<T> t) {{get<0>(t)} -> convertible_to<   string_view>;}
          || requires(ranges::range_value_t<T> t) {{get<0>(t)} -> convertible_to<  wstring_view>;}
          || requires(ranges::range_value_t<T> t) {{get<0>(t)} -> convertible_to< u8string_view>;}
          || requires(ranges::range_value_t<T> t) {{get<0>(t)} -> convertible_to<u16string_view>;}        
          || requires(ranges::range_value_t<T> t) {{get<0>(t)} -> convertible_to<u32string_view>;}
         )
         && (
             requires(ranges::range_value_t<T> t) {{get<1>(t)} -> convertible_to<   string_view>;}
          || requires(ranges::range_value_t<T> t) {{get<1>(t)} -> convertible_to<  wstring_view>;}
          || requires(ranges::range_value_t<T> t) {{get<1>(t)} -> convertible_to< u8string_view>;}
          || requires(ranges::range_value_t<T> t) {{get<1>(t)} -> convertible_to<u16string_view>;}        
          || requires(ranges::range_value_t<T> t) {{get<1>(t)} -> convertible_to<u32string_view>;}
         )         
        )
    process_env(T && r);

    //string pair range with locale
    template<ranges::range T>
        requires (
        requires(ranges::range_value_t<T> r) 
        {
        {tuple_size<ranges::range_value_t<T>>{}} -> convertible_to<integral_constant<std::size_t,2u>>;
        }          
        &&
         (
             requires(ranges::range_value_t<T> t) {{get<0>(t)} -> convertible_to<   string_view>;}
          || requires(ranges::range_value_t<T> t) {{get<0>(t)} -> convertible_to<  wstring_view>;}
          || requires(ranges::range_value_t<T> t) {{get<0>(t)} -> convertible_to< u8string_view>;}
          || requires(ranges::range_value_t<T> t) {{get<0>(t)} -> convertible_to<u16string_view>;}        
          || requires(ranges::range_value_t<T> t) {{get<0>(t)} -> convertible_to<u32string_view>;}
         )
         && (
             requires(ranges::range_value_t<T> t) {{get<1>(t)} -> convertible_to<   string_view>;}
          || requires(ranges::range_value_t<T> t) {{get<1>(t)} -> convertible_to<  wstring_view>;}
          || requires(ranges::range_value_t<T> t) {{get<1>(t)} -> convertible_to< u8string_view>;}
          || requires(ranges::range_value_t<T> t) {{get<1>(t)} -> convertible_to<u16string_view>;}        
          || requires(ranges::range_value_t<T> t) {{get<1>(t)} -> convertible_to<u32string_view>;}
         )         
        )
    process_env(T && r, const std::locale & loc);


    //string pair range
    template<ranges::range T>
        requires (
        requires(ranges::range_value_t<T> r) 
        {
          {tuple_size<ranges::range_value_t<T>>{}} -> convertible_to<integral_constant<std::size_t,2u>>;
        } 
            &&
        (
           requires(ranges::range_value_t<T> t) {{get<0>(t)} -> convertible_to<   string_view>;}
        || requires(ranges::range_value_t<T> t) {{get<0>(t)} -> convertible_to<  wstring_view>;}
        || requires(ranges::range_value_t<T> t) {{get<0>(t)} -> convertible_to< u8string_view>;}
        || requires(ranges::range_value_t<T> t) {{get<0>(t)} -> convertible_to<u16string_view>;}        
        || requires(ranges::range_value_t<T> t) {{get<0>(t)} -> convertible_to<u32string_view>;}
        )
      && requires (ranges::range_value_t<T> t) {{get<1>(t)} -> ranges::range;}
      && (
           requires(ranges::range_value_t<T> t) {{*ranges::begin(get<1>(t))} -> convertible_to<   string_view>;}
        || requires(ranges::range_value_t<T> t) {{*ranges::begin(get<1>(t))} -> convertible_to<  wstring_view>;}
        || requires(ranges::range_value_t<T> t) {{*ranges::begin(get<1>(t))} -> convertible_to< u8string_view>;}
        || requires(ranges::range_value_t<T> t) {{*ranges::begin(get<1>(t))} -> convertible_to<u16string_view>;}        
        || requires(ranges::range_value_t<T> t) {{*ranges::begin(get<1>(t))} -> convertible_to<u32string_view>;}
        )  
    ) 
    process_env(T && t);

    //string pair range with locale
    template<ranges::range T>
        requires (
        requires(ranges::range_value_t<T> r) 
        {
          {tuple_size<ranges::range_value_t<T>>{}} -> convertible_to<integral_constant<std::size_t,2u>>;
        } 
            &&
        (
           requires(ranges::range_value_t<T> t) {{get<0>(t)} -> convertible_to<   string_view>;}
        || requires(ranges::range_value_t<T> t) {{get<0>(t)} -> convertible_to<  wstring_view>;}
        || requires(ranges::range_value_t<T> t) {{get<0>(t)} -> convertible_to< u8string_view>;}
        || requires(ranges::range_value_t<T> t) {{get<0>(t)} -> convertible_to<u16string_view>;}        
        || requires(ranges::range_value_t<T> t) {{get<0>(t)} -> convertible_to<u32string_view>;}
        )
      && requires (ranges::range_value_t<T> t) {{get<1>(t)} -> ranges::range;}
      && (
           requires(ranges::range_value_t<T> t) {{*ranges::begin(get<1>(t))} -> convertible_to<   string_view>;}
        || requires(ranges::range_value_t<T> t) {{*ranges::begin(get<1>(t))} -> convertible_to<  wstring_view>;}
        || requires(ranges::range_value_t<T> t) {{*ranges::begin(get<1>(t))} -> convertible_to< u8string_view>;}
        || requires(ranges::range_value_t<T> t) {{*ranges::begin(get<1>(t))} -> convertible_to<u16string_view>;}        
        || requires(ranges::range_value_t<T> t) {{*ranges::begin(get<1>(t))} -> convertible_to<u32string_view>;}
        )  
    ) 
    process_env(T && t, const std::locale & loc);


    // The rest is implementation-defined
  };
}

#+END_SRC

** Class ~process_limit_handles~

This =limit_handles= property sets all properties to be inherited only expcitly. It closes all unused file-descriptors on POSIX after the fork and removes the inherit flags on Windows. The stanrdard handles are exempted from this.
#+BEGIN_SRC c++

namespace std {
  // Satisfies process_initializer
  class process_limit_handles {
  public:
    // Select all the handles that should be inherited even though they are not 
    // used by any initializer.
    template<class... Handles>
    process_limit_handles(Handles&&... handles);
  };
}

#+END_SRC

** Class ~process_start_dir~

#+BEGIN_SRC c++

namespace std {
  // This class sets the environment for the child environment.
  // Satisfies process_initializer
  class process_start_dir {
      process_start_dir(const std::filesystem::path & start_dir)
  
      // The rest is implementation-defined
  };
}

#+END_SRC

** Namespace ~this_process~ 

This namespace provides information about the current process.

#+BEGIN_SRC c++

namespace std::this_process {
  using native_handle_type = implementation-defined;
  using pid_type = implementation-defined;
  
  // Get the process id of the current process.
  pid_type get_id();
  // Get the native handle of the current process.
  native_handle_type native_handle();
  
  // Get a snapshot of all handles of the process (i.e. file descriptors on POSIX 
  // and handles on Windows) of the current process.
  // NOTE: This function might not work on certain POSIX systems.
  // NOTE: On Windows version older than Windows 8 this function will iterate 
  // all the system handles, meaning it might be quite slow.
  // NOTE: This functionality is utterly prone to race conditions, since other 
  // threads might open or close handles.
  vector<native_handle_type> get_handles();
  template<ranges::output_iterator It>
  It get_handles(It it);

  // Determines if a given handle is a stream-handle, i.e. any handle that can 
  // be used with read and write functions.
  // Stream handles include pipes, regular files and sockets.
  bool is_stream_handle(native_handle_type handle);
}

#+END_SRC

* Acknowledgements

This proposal reflects the effort of the C++ community at C++Now 2019 and afterward. The primary participants are listed as authors on the paper, but many others participated in discussion of details during morning workshop sessions and conference breaks.  

None of this would have been possible without the work and guidance of Klemens Morgenstern, author of boost.process. 

* References
+ Github repository for this proposal https://github.com/JeffGarland/liaw2019-process
+ Additional user examples not included in the proposal https://github.com/JeffGarland/liaw2019-process/tree/master/example
+ An online html version of this proposal is at https://github.com/JeffGarland/liaw2019-process/blob/master/process_proposal.org
+ Isabella Muerte Desert Sessions: Improving hostile environment interactions http://wg21.link/p1275
+ boost.process documentation https://www.boost.org/libs/process 
+ Standard Library wishlist (Matt Austern) https://docs.google.com/document/d/1AC3vkOgFezPaeSZO-fvxgwzEIabw8I_seE7yFG_16Bk/preview
+ cppcast with Klemens on boost.process https://channel9.msdn.com/Shows/CppCast/Episode-72-BoostProcess-with-Klemens-Morgenstern
+ Pacific C++ Klemens on boost.process design https://www.youtube.com/watch?v=uZ4IG1OfeR0
+ ACE Process library documentation http://www.dre.vanderbilt.edu/Doxygen/Stable/libace-doc/a06768.html

